#!/usr/bin/python3
# This script finds positions in each plaintext that will always have the same values as each other,
# regardless of the key used by the permutation cipher. These values of these positions will always
# be equal because the permutation cipher only allows one ciphertext value to represent these plaintext
# letters.
INPUT_FILE = "../../cipher-demo/plaintext_dictionary.txt"
OUTPUT_FILE = "../../decrypt/PlaintextDictionary.cpp"
ENGLISH_LETTERS_WITH_ONLY_ONE_KEY_VALUE = "bjkqvxz"
import inspect
print("Reading plaintext dictionary...")
plaintexts = []
with open(INPUT_FILE, "r") as plaintext_dictionary:
    for line_num, line in enumerate(plaintext_dictionary):
        # Skip over blank lines
        if len(line) > 1:
            # Remove the newline at the end.
            line = line[:-1]
            # Create a dictionary of lists to remember occurrences of each letter in ENGLISH_LETTERS_WITH_ONLY_ONE_KEY_VALUE.
            positions = {letter:[] for letter in ENGLISH_LETTERS_WITH_ONLY_ONE_KEY_VALUE}
            for pos, letter in enumerate(line):
                if letter in ENGLISH_LETTERS_WITH_ONLY_ONE_KEY_VALUE:
                    positions[letter].append(pos)
            print("Line", line_num, positions)
            plaintexts.append((line, positions))
# Auto-generate PlaintextDictionary.cpp.
print("Creating plaintext dictionary in C++...")
with open(OUTPUT_FILE, "w") as cpp:
    cpp.write("// This file is auto-generated by ")
    cpp.write(inspect.getfile(inspect.currentframe()))
    cpp.write("\n")
    cpp.write('#include "PlaintextDictionary.h"\n')
    cpp.write("Plaintext spring2017plaintexts[NUM_PLAINTEXTS_SPRING2017]\n{\n")
    for line, positions in plaintexts:
        # The constructor for Plaintext wants the unencrypted plaintext.
        cpp.write("\t{\n")
        cpp.write('\t\t"')
        cpp.write(repr(line)[1:-1])
        cpp.write('",\n')
        # Next, put the dictionary in brace-initialization form.
        cpp.write("\t\t{\n")
        for letter in positions:
            # Skip lists with only one item.
            # TODO: what to do with plaintexts where none of the letters in ENGLISH_LETTERS_WITH_ONLY_ONE_KEY_VALUE
            #       occur more than once each
            if len(positions[letter]) > 1:
                # Write the char.
                cpp.write("\t\t\t{'")
                cpp.write(letter)
                cpp.write("', ")
                # Write the vector.
                cpp.write("{")
                cpp.write(", ".join(map(str, positions[letter])))
                cpp.write("}},\n")
        cpp.write("\t\t}\n")
        cpp.write("\t},\n")
    cpp.write("};\n")
print("Done.")
